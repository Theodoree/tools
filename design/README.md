


### 创建型
* singleton 单例
* factory 工厂
* builder 创建者
* prototype    原型

```
singleton:初始化一次
factory:创建对象和使用对象的耦合
builder:大致就是使用builder去做断言,减少断言对结构的侵入度
```

### 结构型:
* adapter      适配器
* decorator 装饰器
* proxy 代理
* bridge 桥接
* facade    门面模式
* composite    组合模式
* Flyweight   享元模式

```
适配器模式:适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理 模式、装饰器模式提供的都是跟原始类相同的接口。
装饰器模式:装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持 多个装饰器的嵌套使用。
桥接模式:桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相 对独立地加以改变。
代理模式:代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
门面模式:解决子接口粒度过细的问题,一个业务(分布式业务)可能需要多个接口配合调用,当如果从客户端调用,多次访问会导致网络开支过大,而且无法兼容分布式业务。
组合模式:将一组对象组织成树状结构,利用树状结构的特点,进行递归调用(以统一的接口抽象进行递归调用。)
享元模式: 实际就是将可变和不可变的变量进行抽离,只访问不修改并不会产生数据竞争问题。
```

### 行为性

* observer: 观察者模式
* template: 模板模式
* strategy: 策略模式
* responsibility: 职责链
* finite_state_machine: 状态机
* iterator: 迭代器
* memento: 备忘录
* command 命令模式
```
观察者模式:它将观察者和被观察者解耦。借助设计模式,将一大坨代码拆分为职责更细的小类,以此满足开闭、高内聚低耦合的特性。从而降低代码的复杂度和可拓展性。
模板模式: 个人理解,就是定义一个父类,然后子类可以去重写父类的某些方法,去增强功能,大概就是这么个东西。go没有继承也没有重写机制。所以这里就不写了。(从而可以解决复用代码,拓展问题)
策略模式: 需要定义策略接口和一组实现类，使用基于接口而非实现编 程可灵活替换不同的类，各个实现类可独立变化。(策略注重于替换,工厂模式注重于创建)
职责链模式:多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后 再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。
状态模式:将逻辑控制器和实现进行抽离,每一种状态都会有一个实现类
迭代器模式:复杂的迭代条件,一般使用循环就可以了,复杂场景需要这玩意,像go的hmap.
访问者模式:
备忘录模式: 在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。
命令模式: 将处理过程抽象为一个command,统一的向外接受流量,根据类型的不同使用不同的command,与策略模式不同的一点在于,策略模式最终是要达成一个目的,比如说支付会有支付宝、银行卡、微信支付。
解释器模式:
中介模式:
```










```     
单一职责原则:降低类的复杂度,提高系统的可维护性、健壮性,减少业务变更引起的风险。(一个类只负责一项职责,不要存在多余一个导致类变更的原因)
里氏替换原则:子类可以实现父类的抽象方法,但不能覆盖非抽象方法;子类可以增加自己特有的方法;当子类的方法重载父类的方法时,方法的形参要比父类方法的输入更松散;当子类实现父类的抽象方法,返回值要比父类更严格
依赖倒置原则:高层模块依赖底层模块,应该依靠抽象(go interface);业务模块依赖于底层模块,那么应该抽象出一个接口,通过抽象接口与业务模块进行交互,降低耦合度
接口隔离: (针对接口约束),接口尽量小(当然没有银弹,适度就好),提高内聚,减少对外交互。使得接口用最少的方法去完成最多的事情(针对业务建立专用的接口,将不需要的接口隐藏)。
最少知识原则:尽量降低类之间的耦合度(类与类之间的关系越密切,耦合度就越大。当一个类变化那么对另外一个类的影响也越大)。
开闭原则: 一个软件软件尽量通过拓展的行为来实现变化,而不是通过修改已有代码。
```


golang:
封装:通过首字母大小写来决定访问权限
继承: 没有继承特性,也就没有重载和重写特性,就算是匿名对象,实际上也是在该结构中内嵌了一个成员变量罢了。如果是指针,那么就是一个内嵌的八字节成员,反之就是将所有成员变量内嵌到该结构体内。
多态: 通过interface实现
抽象: 通过Interface实现
